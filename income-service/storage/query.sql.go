// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package storage

import (
	"context"
)

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (id,user_id,type, category, currency ,amount, date) 
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id
`

type CreateTransactionParams struct {
	ID       string
	UserID   string
	Type     string
	Category string
	Currency string
	Amount   float64
	Date     string
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.ID,
		arg.UserID,
		arg.Type,
		arg.Category,
		arg.Currency,
		arg.Amount,
		arg.Date,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteTransactionByID = `-- name: DeleteTransactionByID :exec
DELETE FROM transactions
WHERE id = $1
`

func (q *Queries) DeleteTransactionByID(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTransactionByID, id)
	return err
}

const getExpenses = `-- name: GetExpenses :one
SELECT SUM(amount) FROM transactions
WHERE type =$1 AND user_id = $2
`

type GetExpensesParams struct {
	Type   string
	UserID string
}

func (q *Queries) GetExpenses(ctx context.Context, arg GetExpensesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getExpenses, arg.Type, arg.UserID)
	var sum int64
	err := row.Scan(&sum)
	return sum, err
}

const getIncomes = `-- name: GetIncomes :one
SELECT SUM(amount)  FROM transactions
WHERE type =$1 AND user_id = $2
`

type GetIncomesParams struct {
	Type   string
	UserID string
}

func (q *Queries) GetIncomes(ctx context.Context, arg GetIncomesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getIncomes, arg.Type, arg.UserID)
	var sum int64
	err := row.Scan(&sum)
	return sum, err
}

const getReportByCategory = `-- name: GetReportByCategory :one
SELECT category, amount 
FROM transactions
WHERE type = $1 AND category = $2 AND user_id - $3
`

type GetReportByCategoryParams struct {
	Type     string
	Category string
	UserID   string
}

type GetReportByCategoryRow struct {
	Category string
	Amount   float64
}

func (q *Queries) GetReportByCategory(ctx context.Context, arg GetReportByCategoryParams) (GetReportByCategoryRow, error) {
	row := q.db.QueryRowContext(ctx, getReportByCategory, arg.Type, arg.Category, arg.UserID)
	var i GetReportByCategoryRow
	err := row.Scan(&i.Category, &i.Amount)
	return i, err
}

const getReportByType = `-- name: GetReportByType :many
SELECT category, SUM(amount) as total_aount
FROM transactions
WHERE type = $1 AND user_id = $2 GROUP BY category
`

type GetReportByTypeParams struct {
	Type   string
	UserID string
}

type GetReportByTypeRow struct {
	Category   string
	TotalAount int64
}

func (q *Queries) GetReportByType(ctx context.Context, arg GetReportByTypeParams) ([]GetReportByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getReportByType, arg.Type, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReportByTypeRow
	for rows.Next() {
		var i GetReportByTypeRow
		if err := rows.Scan(&i.Category, &i.TotalAount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionByDate = `-- name: GetTransactionByDate :many
SELECT id, user_id, type, category, currency, amount, date FROM transactions
WHERE type = $1
AND user_id = $2 and date BETWEEN $3 AND $4
`

type GetTransactionByDateParams struct {
	Type   string
	UserID string
	Date   string
	Date_2 string
}

func (q *Queries) GetTransactionByDate(ctx context.Context, arg GetTransactionByDateParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionByDate,
		arg.Type,
		arg.UserID,
		arg.Date,
		arg.Date_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.Category,
			&i.Currency,
			&i.Amount,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT id, user_id, type, category, currency, amount, date FROM transactions
WHERE id = $1
`

func (q *Queries) GetTransactionByID(ctx context.Context, id string) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByID, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Category,
		&i.Currency,
		&i.Amount,
		&i.Date,
	)
	return i, err
}

const getTransactionsByCategory = `-- name: GetTransactionsByCategory :many
SELECT id, user_id, type, category, currency, amount, date FROM transactions
WHERE category = $1 AND user_id = $2
`

type GetTransactionsByCategoryParams struct {
	Category string
	UserID   string
}

func (q *Queries) GetTransactionsByCategory(ctx context.Context, arg GetTransactionsByCategoryParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByCategory, arg.Category, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.Category,
			&i.Currency,
			&i.Amount,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransactionByID = `-- name: UpdateTransactionByID :exec
UPDATE transactions
SET type = $2, category = $3, currency = $4, amount = $5, date = $6
WHERE id = $1
`

type UpdateTransactionByIDParams struct {
	ID       string
	Type     string
	Category string
	Currency string
	Amount   float64
	Date     string
}

func (q *Queries) UpdateTransactionByID(ctx context.Context, arg UpdateTransactionByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateTransactionByID,
		arg.ID,
		arg.Type,
		arg.Category,
		arg.Currency,
		arg.Amount,
		arg.Date,
	)
	return err
}
